import { join } from "@std/path";
import { parse as parseToml } from "@std/toml";
import { stringify as stringifyYaml } from "@std/yaml";
import { $ } from "./util.ts";
import {
  loadModuleSpec,
  ModuleSystemdSpec,
  repoDirFromModules,
} from "./modules.ts";

interface HostSpec {
  setup_ros2?: boolean;
  setup_docker?: boolean;
  modules?: unknown[];
  module_configs?: Record<string, unknown>;
}

function ensureArray(value: unknown): string[] {
  if (!value) return [];
  if (Array.isArray(value)) {
    return value.map((v) => String(v));
  }
  return [String(value)];
}

async function readHostSpec(host: string): Promise<HostSpec> {
  const path = `${Deno.cwd()}/hosts/${host}.toml`;
  const text = await Deno.readTextFile(path);
  return parseToml(text) as HostSpec;
}

function buildUnitContent(
  moduleName: string,
  spec: ModuleSystemdSpec,
  repoDir: string,
  host: string,
  configPath: string | null,
): string {
  const description = spec.description ?? `Psyched ${moduleName} Service`;
  const after = spec.after?.length
    ? spec.after.join(" ")
    : "network.target network-online.target";
  const wants = spec.wants?.length
    ? spec.wants.join(" ")
    : "network-online.target";
  const launchCommand = spec.launch_command?.trim() || null;
  const shutdownCommand = spec.shutdown_command?.trim() || null;
  const launchScript = launchCommand
    ? null
    : (spec.launch ?? `modules/${moduleName}/launch.sh`);
  const shutdownScript = shutdownCommand ? null : (spec.shutdown ?? null);
  const launchPath = launchScript ? join(repoDir, launchScript) : null;
  const shutdownPath = shutdownScript ? join(repoDir, shutdownScript) : null;
  const entrypoint = join(repoDir, "tools", "systemd_entrypoint.sh");
  const workingDir = spec.working_directory
    ? join(repoDir, spec.working_directory)
    : repoDir;
  const restart = spec.restart ?? "on-failure";
  const restartSec = spec.restart_sec ?? 2;
  const user = spec.user ?? Deno.env.get("PSH_SYSTEMD_USER") ??
    Deno.env.get("USER") ?? "root";
  const killMode = spec.kill_mode ?? "control-group";
  const timeoutStop = spec.timeout_stop_sec ?? 20;

  if (!launchCommand && !launchPath) {
    throw new Error(
      `[systemd] Module ${moduleName} has no launch command or script defined.`,
    );
  }

  const execStart = launchCommand
    ? `${entrypoint} bash -lc ${JSON.stringify(launchCommand)}`
    : `${entrypoint} ${launchPath}`;

  const execStop = shutdownCommand
    ? `${entrypoint} bash -lc ${JSON.stringify(shutdownCommand)}`
    : shutdownPath
      ? `${entrypoint} bash -lc "\"${shutdownPath}\""`
      : null;

  const envLines: string[] = [];
  const env = spec.environment ?? {};
  const envEntries = Object.entries(env);
  for (const [key, value] of envEntries) {
    envLines.push(`Environment=${key}=${value}`);
  }
  envLines.push(`Environment=HOST=${host}`);
  envLines.push(`Environment=PSH_MODULE_NAME=${moduleName}`);
  if (configPath) {
    envLines.push(`Environment=PSH_MODULE_CONFIG=${configPath}`);
  }

  const serviceLines = [
    "[Service]",
    "Type=simple",
    `WorkingDirectory=${workingDir}`,
  ];
  if (envLines.length > 0) {
    serviceLines.push(...envLines);
  }
  serviceLines.push(`ExecStart=${execStart}`);
  if (execStop) {
    serviceLines.push(`ExecStop=${execStop}`);
  }
  serviceLines.push(`Restart=${restart}`);
  serviceLines.push(`RestartSec=${restartSec}`);
  serviceLines.push(`User=${user}`);
  serviceLines.push(`KillMode=${killMode}`);
  serviceLines.push(`TimeoutStopSec=${timeoutStop}`);

  return `# Generated by psh systemd
[Unit]
Description=${description}
After=${after}
Wants=${wants}

${serviceLines.join("\n")}

[Install]
WantedBy=multi-user.target
`;
}

async function ensureHostModuleConfig(
  host: string,
  module: string,
  config: Record<string, unknown> | undefined,
): Promise<string | null> {
  const repoDir = repoDirFromModules();
  const configDir = join(repoDir, "hosts", host, "config");
  await Deno.mkdir(configDir, { recursive: true });
  if (config && Object.keys(config).length > 0) {
    const configPath = join(configDir, `${module}.yaml`);
    const yaml = stringifyYaml(config);
    await Deno.writeTextFile(configPath, yaml);
    return configPath;
  }
  return null;
}

async function generateUnits(host: string): Promise<void> {
  const repoDir = repoDirFromModules();
  const hostSpec = await readHostSpec(host);
  const modulesList = ensureArray(hostSpec.modules);
  const configs = hostSpec.module_configs ?? {};
  const outputDir = join(repoDir, "hosts", host, "systemd");
  await Deno.mkdir(outputDir, { recursive: true });

  const desired = new Set<string>();
  for (const moduleName of modulesList) {
    const moduleSpecInfo = await loadModuleSpec(moduleName);
    if (!moduleSpecInfo?.spec.systemd) {
      console.log(
        `[systemd] Module ${moduleName} has no systemd section; skipping.`,
      );
      continue;
    }
    const moduleConfig = (configs[moduleName] ?? {}) as Record<string, unknown>;
    const configPath = await ensureHostModuleConfig(
      host,
      moduleName,
      moduleConfig,
    );
    const unitContent = buildUnitContent(
      moduleName,
      moduleSpecInfo.spec.systemd,
      repoDir,
      host,
      configPath,
    );
    const serviceName = `psyched-${moduleName}.service`;
    const unitPath = join(outputDir, serviceName);
    await Deno.writeTextFile(unitPath, unitContent);
    console.log(`[systemd] Wrote ${unitPath}`);
    desired.add(serviceName);
  }

  for await (const entry of Deno.readDir(outputDir)) {
    if (!entry.isFile || !entry.name.endsWith(".service")) continue;
    if (desired.has(entry.name)) continue;
    const stalePath = join(outputDir, entry.name);
    console.log(`[systemd] Removing stale unit ${stalePath}`);
    await Deno.remove(stalePath).catch(() => undefined);
    await $`sudo systemctl disable --now ${entry.name}`.noThrow();
    const systemdDir = Deno.env.get("SYSTEMD_DIR") ??
      Deno.env.get("PSH_SYSTEMD_DIR") ?? "/etc/systemd/system";
    await $`sudo rm -f ${join(systemdDir, entry.name)}`.noThrow();
  }
}

export async function systemdGenerate(): Promise<void> {
  const hn = await $`hostname -s`.stdout("piped");
  const host = (hn.stdout || hn.stderr || "").toString().trim() ||
    Deno.env.get("HOST") || "default";
  await generateUnits(host);
}

export async function systemdInstall(): Promise<void> {
  await systemdGenerate();
  const hn = await $`hostname -s`.stdout("piped");
  const host = (hn.stdout || hn.stderr || "").toString().trim() ||
    Deno.env.get("HOST") || "default";
  const repoDir = repoDirFromModules();
  const unitsDir = join(repoDir, "hosts", host, "systemd");
  const systemdDir = Deno.env.get("SYSTEMD_DIR") ??
    Deno.env.get("PSH_SYSTEMD_DIR") ?? "/etc/systemd/system";
  for await (const ent of Deno.readDir(unitsDir)) {
    if (!ent.isFile || !ent.name.endsWith(".service")) continue;
    const src = join(unitsDir, ent.name);
    const dest = join(systemdDir, ent.name);
    console.log(`[systemd] Installing ${ent.name}`);
    const copy = await $`sudo cp ${src} ${dest}`.noThrow();
    if (copy.code !== 0) {
      console.error(
        `[systemd] Failed to copy ${ent.name}:`,
        copy.stderr || copy.stdout,
      );
      continue;
    }
    await $`sudo systemctl enable --now ${ent.name}`.noThrow();
  }
  await $`sudo systemctl daemon-reload`.noThrow();
}

export async function systemdUninstall(): Promise<void> {
  const hn = await $`hostname -s`;
  const host = (hn.stdout || hn.stderr || "").toString().trim() ||
    Deno.env.get("HOST") || "default";
  const repoDir = repoDirFromModules();
  const unitsDir = join(repoDir, "hosts", host, "systemd");
  const systemdDir = Deno.env.get("SYSTEMD_DIR") ??
    Deno.env.get("PSH_SYSTEMD_DIR") ?? "/etc/systemd/system";
  try {
    const stat = await Deno.stat(unitsDir);
    if (!stat.isDirectory) {
      console.log(`[systemd] No generated units in ${unitsDir}`);
      return;
    }
  } catch {
    console.log(`[systemd] No generated units in ${unitsDir}`);
    return;
  }
  for await (const ent of Deno.readDir(unitsDir)) {
    if (!ent.isFile || !ent.name.endsWith(".service")) continue;
    const dest = join(systemdDir, ent.name);
    await $`sudo systemctl disable --now ${ent.name}`.noThrow();
    await $`sudo rm -f ${dest}`.noThrow();
    console.log(`[systemd] Removed ${dest}`);
  }
  await $`sudo systemctl daemon-reload`.noThrow();
}
