#!/usr/bin/env bash
set -euo pipefail

# Lightweight Psyched shell orchestrator implemented in Bash.

log() {
  echo "$*" >&2
}

die() {
  echo "Error: $*" >&2
  exit 1
}

warn() {
  echo "Warning: $*" >&2
}

trim() {
  local var="$1"
  var="${var#${var%%[![:space:]]*}}"
  var="${var%${var##*[![:space:]]}}"
  printf '%s' "$var"
}

resolve_path() {
  local target="$1"
  if command -v readlink >/dev/null 2>&1; then
    readlink -f "$target" 2>/dev/null || echo "$target"
  elif command -v python3 >/dev/null 2>&1; then
    python3 -c 'import os, sys; print(os.path.realpath(sys.argv[1]))' "$target"
  else
    echo "$target"
  fi
}

PSH_SELF="${PSH_SELF_OVERRIDE:-$(resolve_path "${BASH_SOURCE[0]}")}"
PSH_REPO_DEFAULT="$(cd "$(dirname "$PSH_SELF")" && pwd)"
PSH_REPO="${PSH_REPO_DIR:-$PSH_REPO_DEFAULT}"
export PSH_SELF

[[ -d "$PSH_REPO" ]] || die "Repository directory not found at '$PSH_REPO'. Set PSH_REPO_DIR to override."

PSH_HOSTS="$PSH_REPO/hosts"
PSH_MODULES="$PSH_REPO/modules"
PSH_TOOLS="$PSH_REPO/tools"
DEFAULT_HOST="$(hostname -s 2>/dev/null || hostname 2>/dev/null || echo localhost)"
DEFAULT_ROS_DISTRO="${ROS_DISTRO:-kilted}"

HOST_NAME=""
HOST_ROS_DISTRO=""
ROS2_PROVISION=0
MODULE_NAMES=()
MODULE_SETUP=()
MODULE_LAUNCH=()
MODULE_TEARDOWN=()

parse_host_config() {
  local host="$1"
  local path="$PSH_HOSTS/$host.toml"
  [[ -f "$path" ]] || die "Unknown host '$host' (expected $path)."

  HOST_NAME=""
  HOST_ROS_DISTRO=""
  ROS2_PROVISION=0
  MODULE_NAMES=()
  MODULE_SETUP=()
  MODULE_LAUNCH=()
  MODULE_TEARDOWN=()

  local in_module=0
  local current_name=""
  local setup_flag=0
  local launch_flag=0
  local teardown_flag=0

  while IFS= read -r raw_line || [[ -n "$raw_line" ]]; do
    local line="${raw_line%%#*}"
    line="$(trim "$line")"
    [[ -z "$line" ]] && continue

    if [[ "$line" == "[[modules]]" ]]; then
      if [[ -n "$current_name" ]]; then
        MODULE_NAMES+=("$current_name")
        MODULE_SETUP+=("$setup_flag")
        MODULE_LAUNCH+=("$launch_flag")
        MODULE_TEARDOWN+=("$teardown_flag")
      fi
      in_module=1
      current_name=""
      setup_flag=0
      launch_flag=0
      teardown_flag=0
      continue
    fi

    if [[ $line =~ ^name[[:space:]]*=[[:space:]]*"(.*)"$ ]]; then
      local value="${BASH_REMATCH[1]}"
      if (( in_module )); then
        current_name="$value"
      else
        HOST_NAME="$value"
      fi
      continue
    fi

    if [[ $line =~ ^ros2_provision[[:space:]]*=[[:space:]]*(true|false)$ ]]; then
      ROS2_PROVISION=$([[ "${BASH_REMATCH[1]}" == "true" ]] && echo 1 || echo 0)
      continue
    fi

    if [[ $line =~ ^ros2_distro[[:space:]]*=[[:space:]]*"(.*)"$ ]]; then
      HOST_ROS_DISTRO="${BASH_REMATCH[1]}"
      continue
    fi

    if (( in_module )); then
      if [[ $line =~ ^setup[[:space:]]*=[[:space:]]*(true|false)$ ]]; then
        setup_flag=$([[ "${BASH_REMATCH[1]}" == "true" ]] && echo 1 || echo 0)
        continue
      fi
      if [[ $line =~ ^launch[[:space:]]*=[[:space:]]*(true|false)$ ]]; then
        launch_flag=$([[ "${BASH_REMATCH[1]}" == "true" ]] && echo 1 || echo 0)
        continue
      fi
      if [[ $line =~ ^teardown[[:space:]]*=[[:space:]]*(true|false)$ ]]; then
        teardown_flag=$([[ "${BASH_REMATCH[1]}" == "true" ]] && echo 1 || echo 0)
        continue
      fi
    fi
  done < "$path"

  if [[ -n "$current_name" ]]; then
    MODULE_NAMES+=("$current_name")
    MODULE_SETUP+=("$setup_flag")
    MODULE_LAUNCH+=("$launch_flag")
    MODULE_TEARDOWN+=("$teardown_flag")
  fi

  [[ -n "$HOST_NAME" ]] || HOST_NAME="$host"
}

join_actions() {
  local actions=()
  local action
  for action in "$@"; do
    [[ -n "$action" ]] && actions+=("$action")
  done
  if (( ${#actions[@]} == 0 )); then
    printf 'no actions'
  else
    local IFS=", "
    printf '%s' "${actions[*]}"
  fi
}

run_module_script() {
  local module="$1"
  local action="$2"
  local script="$PSH_MODULES/$module/$action.sh"
  if [[ ! -f "$script" ]]; then
    warn "Module '$module' has no $action script at $script; skipping"
    return 0
  fi
  log "[$module] $action"
  (cd "$PSH_REPO" && bash "$script")
}

plan_teardown_for_missing_modules() {
  declare -A present=()
  local idx
  for idx in "${!MODULE_NAMES[@]}"; do
    present["${MODULE_NAMES[$idx]}"]=1
  done

  [[ -d "$PSH_MODULES" ]] || return 0
  while IFS= read -r module; do
    [[ -n "$module" ]] || continue
    if [[ -z "${present[$module]:-}" && -f "$PSH_MODULES/$module/teardown.sh" ]]; then
      echo "- module $module: teardown (not in host config)"
    fi
  done < <(find "$PSH_MODULES" -mindepth 1 -maxdepth 1 -type d -printf '%f\n' 2>/dev/null | sort)
}

apply_teardown_for_missing_modules() {
  declare -A present=()
  local idx
  for idx in "${!MODULE_NAMES[@]}"; do
    present["${MODULE_NAMES[$idx]}"]=1
  done
  [[ -d "$PSH_MODULES" ]] || return 0
  while IFS= read -r module; do
    [[ -n "$module" ]] || continue
    if [[ -z "${present[$module]:-}" ]]; then
      run_module_script "$module" "teardown"
    fi
  done < <(find "$PSH_MODULES" -mindepth 1 -maxdepth 1 -type d -printf '%f\n' 2>/dev/null | sort)
}

psh_env() {
  local script="$PSH_TOOLS/setup_env.sh"
  [[ -f "$script" ]] || die "Environment script not found at $script"
  WORKSPACE_PATH="$PSH_REPO" bash "$script"
}

psh_ros2() {
  local distro="$DEFAULT_ROS_DISTRO"
  local script="$PSH_TOOLS/install_ros2.sh"
  local force=0

  while (( $# > 0 )); do
    case "$1" in
      --distro)
        (( $# >= 2 )) || die "--distro requires an argument"
        distro="$2"
        shift 2
        ;;
      --script)
        (( $# >= 2 )) || die "--script requires a path"
        script="$2"
        shift 2
        ;;
      --force)
        force=1
        shift
        ;;
      -h|--help)
        cat <<EOF
Usage: psh ros2 [--distro <name>] [--script <path>] [--force]

Ensures ROS 2 is installed. Skips if \`ros2\` is already available unless --force is passed.
EOF
        return 0
        ;;
      *)
        die "Unknown ros2 option '$1'"
        ;;
    esac
  done

  if command -v ros2 >/dev/null 2>&1 && (( force == 0 )); then
    echo "ros2 command already present; skipping install (use --force to reinstall)."
    return 0
  fi

  [[ -f "$script" ]] || die "ROS 2 install script not found at $script"
  echo "Installing ROS 2 distro '$distro' via $script"
  ROS_DISTRO="$distro" WORKSPACE_PATH="$PSH_REPO" bash "$script"
}

psh_module() {
  (( $# >= 1 )) || die "Usage: psh module <setup|remove|launch> <module>..."
  local subcommand="$1"
  shift
  (( $# >= 1 )) || die "At least one module name is required"

  local action
  case "$subcommand" in
    setup)
      action="setup"
      ;;
    remove)
      action="teardown"
      ;;
    launch)
      action="launch"
      ;;
    *)
      die "Unknown module subcommand '$subcommand'"
      ;;
  esac

  local module
  for module in "$@"; do
    run_module_script "$module" "$action"
  done
}

host_plan() {
  local host="${1:-$DEFAULT_HOST}"
  parse_host_config "$host"
  echo "Host plan for $HOST_NAME (source: $PSH_HOSTS/$host.toml)"
  if (( ROS2_PROVISION )); then
    local distro="$HOST_ROS_DISTRO"
    [[ -n "$distro" ]] || distro="$DEFAULT_ROS_DISTRO"
    echo "- ensure ROS 2 ($distro)"
  fi
  local idx
  for idx in "${!MODULE_NAMES[@]}"; do
    local module="${MODULE_NAMES[$idx]}"
    local actions=()
    (( ${MODULE_SETUP[$idx]} == 1 )) && actions+=("setup")
    (( ${MODULE_LAUNCH[$idx]} == 1 )) && actions+=("launch")
    (( ${MODULE_TEARDOWN[$idx]} == 1 )) && actions+=("teardown")
    echo "- module $module: $(join_actions "${actions[@]}")"
  done
  plan_teardown_for_missing_modules
}

host_apply() {
  local host="${1:-$DEFAULT_HOST}"
  parse_host_config "$host"
  echo "Applying host $HOST_NAME from $PSH_HOSTS/$host.toml"

  if (( ROS2_PROVISION )); then
    local distro="$HOST_ROS_DISTRO"
    [[ -n "$distro" ]] || distro="$DEFAULT_ROS_DISTRO"
    psh_ros2 --distro "$distro"
  fi

  local idx
  for idx in "${!MODULE_NAMES[@]}"; do
    if (( ${MODULE_TEARDOWN[$idx]} == 1 )); then
      run_module_script "${MODULE_NAMES[$idx]}" "teardown"
    fi
  done

  apply_teardown_for_missing_modules

  for idx in "${!MODULE_NAMES[@]}"; do
    if (( ${MODULE_SETUP[$idx]} == 1 )); then
      run_module_script "${MODULE_NAMES[$idx]}" "setup"
    fi
  done

  for idx in "${!MODULE_NAMES[@]}"; do
    if (( ${MODULE_LAUNCH[$idx]} == 1 )); then
      run_module_script "${MODULE_NAMES[$idx]}" "launch"
    fi
  done
}

psh_host() {
  (( $# >= 1 )) || die "Usage: psh host <plan|apply> [hostname]"
  local subcommand="$1"
  shift
  case "$subcommand" in
    plan)
      host_plan "${1:-$DEFAULT_HOST}"
      ;;
    apply)
      host_apply "${1:-$DEFAULT_HOST}"
      ;;
    *)
      die "Unknown host subcommand '$subcommand'"
      ;;
  esac
}

psh_update() {
  local host="$DEFAULT_HOST"
  while (( $# > 0 )); do
    case "$1" in
      --host)
        (( $# >= 2 )) || die "--host requires a value"
        host="$2"
        shift 2
        ;;
      *)
        die "Unknown update option '$1'"
        ;;
    esac
  done

  [[ -d "$PSH_REPO/.git" ]] || die "Repository at $PSH_REPO is not a git checkout"
  echo "Updating repository at $PSH_REPO"
  (cd "$PSH_REPO" && git fetch --tags --prune)
  (cd "$PSH_REPO" && git pull --ff-only)
  "$PSH_SELF" host apply "$host"
}

usage() {
  cat <<'EOF'
Usage: psh <command> [args]

Commands:
  env                Evaluate ROS workspace environment helper
  ros2 [options]     Ensure ROS 2 is installed
  module <subcmd>    Run module lifecycle scripts (setup/remove/launch)
  host <subcmd>      Plan or apply host configurations
  update [--host H]  Update repository and reapply host configuration
  help               Show this message
EOF
}

main() {
  (( $# >= 1 )) || { usage; exit 1; }
  local command="$1"
  shift
  case "$command" in
    env)
      psh_env "$@"
      ;;
    ros2)
      psh_ros2 "$@"
      ;;
    module)
      psh_module "$@"
      ;;
    host)
      psh_host "$@"
      ;;
    update)
      psh_update "$@"
      ;;
    help|-h|--help)
      usage
      ;;
    *)
      die "Unknown command '$command'"
      ;;
  esac
}

main "$@"
