import { join } from "$std/path/mod.ts";
import { colors } from "$cliffy/ansi/colors.ts";
import { $ } from "$dax";
import {
  locateModuleDir,
  moduleConfig,
  resolveModuleScript,
} from "./module.ts";
import { repoRoot } from "./paths.ts";

function homeDir(): string {
  const home = Deno.env.get("HOME");
  if (!home) throw new Error("HOME environment variable is not set");
  return home;
}

function systemdUserDir(): string {
  const base = Deno.env.get("XDG_CONFIG_HOME") ?? join(homeDir(), ".config");
  const dir = join(base, "systemd", "user");
  Deno.mkdirSync(dir, { recursive: true });
  return dir;
}

function unitName(module: string): string {
  return `psh-module-${module}.service`;
}

function unitPath(module: string): string {
  return join(systemdUserDir(), unitName(module));
}

function environmentBlock(env?: Record<string, string>): string {
  if (!env) return "";
  return Object.entries(env)
    .map(([key, value]) => `Environment=${key}=${value}`)
    .join("\n");
}

export async function setupSystemd(module: string): Promise<void> {
  const config = moduleConfig(module);
  if (!config.launch) {
    throw new Error(`module '${module}' does not declare a launch script`);
  }
  const moduleDir = locateModuleDir(module);
  const launch = await resolveModuleScript(config.launch, moduleDir);
  const shutdown = config.shutdown
    ? await resolveModuleScript(config.shutdown, moduleDir)
    : undefined;
  const envBlock = environmentBlock({ PSYCHED_REPO_ROOT: repoRoot() });
  const execStop = shutdown ? `ExecStop=/usr/bin/env bash ${shutdown}\n` : "";
  const envSection = envBlock ? `${envBlock}\n` : "";
  const contents =
    `# Autogenerated by psh systemd setup\n[Unit]\nDescription=Psyched module ${module}\nAfter=network.target\n\n[Service]\nType=simple\nWorkingDirectory=${moduleDir}\nExecStart=/usr/bin/env bash ${launch}\n${execStop}${envSection}Restart=on-failure\n\n[Install]\nWantedBy=default.target\n`;
  Deno.writeTextFileSync(unitPath(module), contents);
  console.log(colors.green(`Wrote ${unitPath(module)}`));
}

export function teardownSystemd(module: string): void {
  const path = unitPath(module);
  try {
    Deno.removeSync(path);
    console.log(colors.yellow(`Removed ${path}`));
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      console.warn(colors.yellow(`Unit file ${path} not found`));
    } else {
      throw error;
    }
  }
}

async function systemctl(action: string, module: string): Promise<void> {
  const unit = unitName(module);
  await $`systemctl --user ${action} ${unit}`.stdout("inherit").stderr(
    "inherit",
  );
}

export async function enableSystemd(module: string): Promise<void> {
  await systemctl("enable", module);
}

export async function disableSystemd(module: string): Promise<void> {
  await systemctl("disable", module);
}

export async function startSystemd(module: string): Promise<void> {
  await systemctl("start", module);
}

export async function stopSystemd(module: string): Promise<void> {
  await systemctl("stop", module);
}
