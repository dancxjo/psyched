#!/usr/bin/env bash
# Lightweight cron-based service manager for psyched modules
# Replaces memory-intensive systemd services

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"
CRON_DIR="${HOME}/.config/psyched/cron"
PID_DIR="${HOME}/.config/psyched/pids"
LOG_DIR="${HOME}/.config/psyched/logs"
WRAPPER_DIR="${HOME}/.config/psyched/wrappers"

# Functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

ensure_dirs() {
    mkdir -p "$CRON_DIR" "$PID_DIR" "$LOG_DIR" "$WRAPPER_DIR"
}

get_enabled_modules() {
    local host_dir="${REPO_DIR}/hosts"
    local hostname="${1:-$(hostname -s)}"
    local enabled_dir="${host_dir}/${hostname}/enabled"
    
    if [[ ! -d "${enabled_dir}" ]]; then
        log_warning "No enabled modules found for host '${hostname}'"
        return 1
    fi
    
    find "${enabled_dir}" -maxdepth 1 -type f -o -type l | while read -r file; do
        basename "$file" | sed 's/^[0-9]*-//'
    done
}

create_lightweight_wrapper() {
    local module_name="$1"
    local wrapper_file="${WRAPPER_DIR}/psyched-${module_name}"
    
    cat > "$wrapper_file" << EOF
#!/usr/bin/env bash
# Lightweight wrapper for $module_name module
# Generated by cron_manager.sh on $(date)

set -euo pipefail

MODULE_NAME="$module_name"
REPO_DIR="$REPO_DIR"
PID_FILE="$PID_DIR/psyched-\${MODULE_NAME}.pid"
LOG_FILE="$LOG_DIR/psyched-\${MODULE_NAME}.log"

# Function to cleanup on exit
cleanup() {
    local exit_code=\$?
    echo "[\$(date '+%Y-%m-%d %H:%M:%S')] Service \$MODULE_NAME stopping (exit code: \$exit_code)" >> "\$LOG_FILE"
    rm -f "\$PID_FILE"
    exit \$exit_code
}

trap cleanup EXIT INT TERM

# Check if already running
if [[ -f "\$PID_FILE" ]] && kill -0 \$(cat "\$PID_FILE") 2>/dev/null; then
    echo "[\$(date '+%Y-%m-%d %H:%M:%S')] \$MODULE_NAME already running with PID \$(cat "\$PID_FILE")" >> "\$LOG_FILE"
    exit 0
fi

# Write our PID
echo \$\$ > "\$PID_FILE"

# Start logging
echo "[\$(date '+%Y-%m-%d %H:%M:%S')] Starting \$MODULE_NAME service" >> "\$LOG_FILE"

# Change to repo directory
cd "\$REPO_DIR"

# Minimal environment setup - avoid heavy ROS sourcing
export PATH="\$HOME/.local/bin:/usr/local/bin:\$PATH"
export ROS_DOMAIN_ID=\${ROS_DOMAIN_ID:-0}
export VOICE_ENGINE=espeak
export ESPEAK_VOICE=en-us
export PIPER_MODEL=en_US-ryan-high
export PIPER_VOICES_DIR=/opt/piper/voices

# Only source ROS if absolutely necessary and do it minimally
if [[ -f "/opt/ros/kilted/setup.bash" ]]; then
    # Source ROS environment with minimal overhead
    source "/opt/ros/kilted/setup.bash" 2>/dev/null || true
    
    # Only source workspace if it exists and is built
    if [[ -f "\$REPO_DIR/install/setup.bash" ]]; then
        source "\$REPO_DIR/install/setup.bash" 2>/dev/null || true
    fi
fi

# Execute the module launch script with output redirected to log
echo "[\$(date '+%Y-%m-%d %H:%M:%S')] Executing launch script..." >> "\$LOG_FILE"
exec "\$REPO_DIR/modules/\$MODULE_NAME/launch.sh" >> "\$LOG_FILE" 2>&1
EOF

    chmod +x "$wrapper_file"
    log_success "Created wrapper for $module_name"
}

install_cron_entry() {
    local module_name="$1"
    local wrapper_file="${WRAPPER_DIR}/psyched-${module_name}"
    
    # Create cron entry that runs every minute and checks if service is running
    local cron_entry="* * * * * $wrapper_file >/dev/null 2>&1"
    
    # Add to crontab if not already present
    (crontab -l 2>/dev/null || true; echo "$cron_entry") | \
    grep -v "# psyched-${module_name}" | \
    { cat; echo "$cron_entry # psyched-${module_name}"; } | \
    crontab -
    
    log_success "Installed cron entry for $module_name"
}

remove_cron_entry() {
    local module_name="$1"
    
    # Remove cron entry
    crontab -l 2>/dev/null | grep -v "# psyched-${module_name}" | crontab - || true
    
    # Remove wrapper and PID file
    rm -f "${WRAPPER_DIR}/psyched-${module_name}"
    rm -f "${PID_DIR}/psyched-${module_name}.pid"
    
    log_success "Removed cron entry for $module_name"
}

install_enabled() {
    local hostname="${1:-$(hostname -s)}"
    
    ensure_dirs
    
    log_info "Installing cron entries for enabled modules on host '$hostname'"
    
    if ! get_enabled_modules "$hostname" >/dev/null 2>&1; then
        log_error "No enabled modules found for host '$hostname'"
        exit 1
    fi
    
    get_enabled_modules "$hostname" | while read -r module; do
        create_lightweight_wrapper "$module"
        install_cron_entry "$module"
    done
    
    log_success "All enabled modules installed in cron"
    log_info "Services will start automatically within 1 minute"
}

uninstall_all() {
    log_info "Removing all psyched cron entries"
    
    # Remove all psyched cron entries
    crontab -l 2>/dev/null | grep -v "# psyched-" | crontab - || true
    
    # Clean up wrapper files and PID files
    rm -rf "$WRAPPER_DIR" "$PID_DIR"
    mkdir -p "$WRAPPER_DIR" "$PID_DIR"
    
    log_success "All psyched cron entries removed"
}

status() {
    log_info "Psyched cron service status:"
    echo
    
    # Show active cron entries
    echo "=== CRON ENTRIES ==="
    if crontab -l 2>/dev/null | grep "# psyched-" | head -10; then
        echo
    else
        echo "No psyched cron entries found"
        echo
    fi
    
    # Show running processes
    echo "=== RUNNING PROCESSES ==="
    if [[ -d "$PID_DIR" ]]; then
        for pid_file in "$PID_DIR"/psyched-*.pid; do
            if [[ -f "$pid_file" ]]; then
                local module_name=$(basename "$pid_file" .pid | sed 's/^psyched-//')
                local pid=$(cat "$pid_file" 2>/dev/null || echo "")
                if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                    echo "✓ $module_name (PID: $pid)"
                else
                    echo "✗ $module_name (dead, removing stale PID file)"
                    rm -f "$pid_file"
                fi
            fi
        done
    else
        echo "No PID directory found"
    fi
}

stop_all() {
    log_info "Stopping all psyched services"
    
    if [[ -d "$PID_DIR" ]]; then
        for pid_file in "$PID_DIR"/psyched-*.pid; do
            if [[ -f "$pid_file" ]]; then
                local module_name=$(basename "$pid_file" .pid | sed 's/^psyched-//')
                local pid=$(cat "$pid_file" 2>/dev/null || echo "")
                if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                    log_info "Stopping $module_name (PID: $pid)"
                    kill -TERM "$pid" 2>/dev/null || true
                    sleep 1
                    if kill -0 "$pid" 2>/dev/null; then
                        log_warning "Force killing $module_name"
                        kill -KILL "$pid" 2>/dev/null || true
                    fi
                fi
                rm -f "$pid_file"
            fi
        done
    fi
    
    log_success "All services stopped"
}

start_module() {
    local module_name="$1"
    local wrapper_file="${WRAPPER_DIR}/psyched-${module_name}"
    
    if [[ ! -f "$wrapper_file" ]]; then
        log_error "Module $module_name not installed. Run: install-enabled first"
        exit 1
    fi
    
    log_info "Starting $module_name manually..."
    "$wrapper_file" &
    log_success "$module_name started in background"
}

stop_module() {
    local module_name="$1"
    local pid_file="${PID_DIR}/psyched-${module_name}.pid"
    
    if [[ -f "$pid_file" ]]; then
        local pid=$(cat "$pid_file" 2>/dev/null || echo "")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            log_info "Stopping $module_name (PID: $pid)"
            kill -TERM "$pid" 2>/dev/null || true
            sleep 1
            if kill -0 "$pid" 2>/dev/null; then
                log_warning "Force killing $module_name"
                kill -KILL "$pid" 2>/dev/null || true
            fi
        fi
        rm -f "$pid_file"
        log_success "$module_name stopped"
    else
        log_warning "$module_name not running"
    fi
}

show_logs() {
    local module_name="$1"
    local lines="${2:-20}"
    local log_file="${LOG_DIR}/psyched-${module_name}.log"
    
    if [[ -f "$log_file" ]]; then
        log_info "Last $lines lines from $module_name log:"
        tail -n "$lines" "$log_file"
    else
        log_warning "No log file found for $module_name"
    fi
}

show_help() {
    cat << EOF
Psyched Service Manager - Lightweight Cron-Based Services

Usage: $0 <command> [options]

Commands:
    install-enabled [host]   Install cron entries for all enabled modules
    uninstall-all           Remove all psyched cron entries and stop services
    start <module>          Manually start a specific module
    stop <module>           Stop a specific module  
    stop-all               Stop all running services
    status                 Show status of cron entries and running processes
    logs <module> [lines]  Show recent logs for a module (default: 20 lines)
    help                   Show this help message

Examples:
    $0 install-enabled              # Install cron entries for enabled modules
    $0 status                       # Show current status
    $0 start voice                  # Manually start voice module
    $0 stop foot                    # Stop foot module
    $0 logs voice 50                # Show last 50 log lines for voice
    $0 stop-all                     # Stop all services
    $0 uninstall-all               # Remove everything

Notes:
- Services auto-restart via cron every minute if they crash
- Logs are stored in $LOG_DIR
- Lightweight and memory-efficient
- No root privileges required

EOF
}

# Main script logic
case "${1:-help}" in
    install-enabled)
        install_enabled "${2:-}"
        ;;
    uninstall-all)
        uninstall_all
        ;;
    start)
        if [[ -z "${2:-}" ]]; then
            log_error "Module name required"
            show_help
            exit 1
        fi
        start_module "$2"
        ;;
    stop)
        if [[ -z "${2:-}" ]]; then
            log_error "Module name required"
            show_help
            exit 1
        fi
        stop_module "$2"
        ;;
    stop-all)
        stop_all
        ;;
    status)
        status
        ;;
    logs)
        if [[ -z "${2:-}" ]]; then
            log_error "Module name required"
            show_help
            exit 1
        fi
        show_logs "$2" "${3:-20}"
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        log_error "Unknown command: $1"
        show_help
        exit 1
        ;;
esac