use std::time::{Duration, Instant};

use parking_lot::Mutex;
use serde::{Deserialize, Serialize};

/// Representation of a single chat message exchanged over the socket.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct Message {
    /// Role of the message author.
    pub role: String,
    /// Natural language content of the message.
    pub content: String,
}

/// Lightweight statistics maintained for each conversation.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SessionStats {
    /// Number of tokens generated by the assistant so far.
    pub generated_tokens: usize,
    /// Timestamp when the session was created.
    pub started_at: Instant,
}

impl SessionStats {
    /// Creates stats initialised at the current time.
    pub fn new() -> Self {
        Self {
            generated_tokens: 0,
            started_at: Instant::now(),
        }
    }

    /// Updates the generated token count.
    pub fn add_tokens(&mut self, count: usize) {
        self.generated_tokens += count;
    }

    /// Returns the time elapsed since creation.
    pub fn uptime(&self) -> Duration {
        self.started_at.elapsed()
    }
}

impl Default for SessionStats {
    fn default() -> Self {
        Self::new()
    }
}

/// Maintains the conversation history and statistics for a single WebSocket session.
#[derive(Debug, Default)]
pub struct ConversationSession {
    history: Mutex<Vec<Message>>,
    stats: Mutex<SessionStats>,
}

impl ConversationSession {
    /// Create a new session, optionally seeding it with a system prompt.
    pub fn new(system_prompt: Option<&str>) -> Self {
        let mut history = Vec::new();
        if let Some(prompt) = system_prompt {
            history.push(Message {
                role: "system".into(),
                content: prompt.to_string(),
            });
        }
        Self {
            history: Mutex::new(history),
            stats: Mutex::new(SessionStats::new()),
        }
    }

    /// Append a message to the conversation.
    pub fn push(&self, role: impl Into<String>, content: impl Into<String>) {
        let msg = Message {
            role: role.into(),
            content: content.into(),
        };
        self.history.lock().push(msg);
    }

    /// Returns a copy of the full conversation history.
    pub fn history(&self) -> Vec<Message> {
        self.history.lock().clone()
    }

    /// Clears the conversation state, preserving statistics start time.
    pub fn reset(&self, system_prompt: Option<&str>) {
        let mut history = self.history.lock();
        history.clear();
        if let Some(prompt) = system_prompt {
            history.push(Message {
                role: "system".into(),
                content: prompt.to_string(),
            });
        }
        let mut stats = self.stats.lock();
        *stats = SessionStats::new();
    }

    /// Adds generated tokens to statistics.
    pub fn add_generated_tokens(&self, count: usize) {
        self.stats.lock().add_tokens(count);
    }

    /// Returns the session statistics snapshot.
    pub fn stats(&self) -> SessionStats {
        self.stats.lock().clone()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn session_stores_messages_and_tokens() {
        let session = ConversationSession::new(Some("System prompt"));
        session.push("user", "Hello");
        session.push("assistant", "Hi there");
        session.add_generated_tokens(5);

        let history = session.history();
        assert_eq!(history.len(), 3);
        assert_eq!(history[0].role, "system");
        assert_eq!(history[1].content, "Hello");

        let stats = session.stats();
        assert_eq!(stats.generated_tokens, 5);
        assert!(stats.uptime() >= Duration::from_secs(0));
    }

    #[test]
    fn reset_clears_history_but_resets_prompt() {
        let session = ConversationSession::new(Some("Original"));
        session.push("user", "Hi");
        session.reset(Some("New"));

        let history = session.history();
        assert_eq!(history.len(), 1);
        assert_eq!(history[0].content, "New");
    }
}
